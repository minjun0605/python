# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean

def func_a(arr):
    """
    [기능] 배열을 2번 이어붙여(확장 배열) 회전(순환 이동) 결과를 '연속 부분 배열'로 찾을 수 있게 만든다.
    예) arr = [1,2,3,4]  ->  [1,2,3,4,1,2,3,4]

    [이유]
    arr을 회전한 모든 결과는 (arr + arr) 안에서 길이 len(arr)짜리 연속 구간으로 등장한다.
    """
    ret = arr + arr
    return ret


def func_b(first, second):
    """
    [기능] 두 배열의 '구성 원소(값의 종류와 개수)'가 완전히 같은지 확인한다.
    [왜 필요한가?]https://github.com/minjun0605/python/tree/main
    회전은 "순서만 바꾸는 작업"이므로,
    원소의 종류/개수가 다르면 절대 회전으로 같아질 수 없다.
    -> 이 단계에서 다르면 False로 탈락시킴.

    [방법]
    문제 조건: 원소 값 범위가 0~1000 이므로 크기 1001짜리 카운터 배열을 사용한다.
    - first의 원소는 +1
    - second의 원소는 -1
    최종적으로 모든 카운터 값이 0이면 두 배열의 구성 원소가 동일하다.
    """
    MAX_NUMBER = 1001                 # 값이 0~1000이므로 인덱스 0~1000 사용
    counter = [0 for _ in range(MAX_NUMBER)]

    # zip(first, second)로 같은 위치의 원소를 동시에 순회
    # first 원소는 +1, second 원소는 -1 해서 "개수 차이"를 누적
    for f, s in zip(first, second):
        counter[f] += 1
        counter[s] -= 1

    # 하나라도 0이 아니면: 어떤 값의 개수가 다르다는 뜻 -> 회전 불가
    for c in counter:
        if c != 0:
            return False

    # 전부 0이면: 구성 원소(종류/개수) 동일
    return True


def func_c(first, second):
    """
    [기능] first(확장 배열) 안에 second가 '연속 부분 배열'로 존재하는지 확인한다.

    - first: arrA + arrA (길이 2N)
    - second: arrB (길이 N)

    [핵심 아이디어]
    arrA의 회전 결과는 arrA+arrA 안에서 길이 N짜리 연속 구간으로 나타난다.
    따라서 first에서 길이 N의 모든 시작점(0~N-1)을 검사해 second와 같은 구간이 있으면 True.

    [주의]
    시작점은 0 ~ N-1까지만 보면 충분하다.
    (N 이후 시작점은 앞쪽 회전 결과와 중복되기 때문)
    """
    length = len(second)

    # 가능한 시작 위치 i = 0 ~ length-1 까지 검사
    for i in range(length):
        # first의 i부터 i+length 전까지의 구간이 second와 같으면 회전 가능
        if first[i : i + length] == second:
            return True

    # 끝까지 못 찾으면 회전 불가
    return False


def solution(arrA, arrB):
    """
    [목표] arrA를 회전(오른쪽으로 밀고 마지막 원소를 맨 앞으로)해서 arrB를 만들 수 있으면 True, 아니면 False

    [전체 알고리즘 흐름]
    1) 길이가 다르면 회전해도 길이는 바뀌지 않으므로 False
    2) 구성 원소가 다르면(값 종류/개수 다름) 회전해도 같아질 수 없으므로 False
    3) arrA를 두 번 붙인 확장 배열(arrA+arrA)을 만든다.
    4) 그 확장 배열 안에 arrB가 연속 부분 배열로 존재하면 True, 아니면 False
    """

    # 1) 길이 검사: 길이가 다르면 회전으로 같아질 수 없음
    if len(arrA) != len(arrB):
        return False

    # 2) 구성 원소 검사: 원소 종류/개수가 다르면 회전해도 같아질 수 없음
    if func_b(arrA, arrB):

        # 3) 확장 배열 생성: arrA + arrA
        arrA_temp = func_a(arrA)

        # 4) 확장 배열 안에서 arrB가 연속 부분 배열로 존재하는지 확인
        if func_c(arrA_temp, arrB):
            return True

    # 위 조건을 만족하지 못하면 회전 불가
    return False

arrA1 = [1, 2, 3, 4]
arrB1 = [3, 4, 1, 2]
ret1 = solution(arrA1, arrB1)

print("solution 함수의 반환 값은", ret1, "입니다.")

arrA2 = [1, 2, 3, 4]
arrB2 = [1, 4, 2, 3]
ret2 = solution(arrA2, arrB2)

print("solution 함수의 반환 값은", ret2, "입니다.")

# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
# (한글 주석/문자열이 깨지지 않도록 인코딩을 UTF-8로 지정)

def solution(bishops):
    """
    [문제 요약]
    - 8x8 체스판에 여러 개의 비숍이 놓여 있다.
    - 비숍은 대각선 방향으로 원하는 만큼 이동 가능하다.
    - 비숍이 한 번에 이동 가능한 경로에 있는 칸은 '공격되는 칸'이다.
      즉, 그 칸에 말을 놓으면 비숍에게 바로 잡힌다.
    - 목표: 비숍에게 한 번에 잡히지 않게 "새로운 말"을 놓을 수 있는 빈칸의 개수를 구한다.
      (비숍이 이미 있는 칸에는 당연히 놓을 수 없음)

    [아이디어]
    1) 비숍이 있는 칸들을 occupied(set)에 저장
    2) 각 비숍에서 4방향 대각선으로 뻗어가며 공격 가능한 칸들을 attacked(set)에 저장
       - 다른 비숍(말)을 만나면 그 칸까지는 공격 가능(잡을 수 있음)이지만,
         그 뒤로는 이동이 막히므로 더 진행하지 않는다.
    3) 전체 64칸을 돌며 (occupied에도 없고 attacked에도 없는) 안전한 칸만 count
    """

    # ------------------------------------------------------------
    # 1) 비숍이 놓인 칸(점유된 칸)들을 저장하는 집합(set)
    #    - set을 쓰는 이유: (row, col)이 있는지 O(1)에 빠르게 확인 가능
    # ------------------------------------------------------------
    occupied = set()  # (row, col) 형태로 저장. row/col은 0~7 범위

    # bishops는 예: ["D5", "E8", "G2"]처럼 들어온다.
    # '알파벳+숫자' 형태:
    #   - 알파벳(A~H): 가로(열, column)
    #   - 숫자(1~8): 세로(행, row)
    for pos in bishops:
        # 열(col) 변환:
        # ord('A')=65, ord('B')=66 ... 이므로
        # ord(pos[0]) - ord('A') 하면 A->0, B->1 ... H->7
        col = ord(pos[0]) - ord('A')

        # 행(row) 변환:
        # pos[1]은 '1'~'8' 문자이므로 int로 바꾼 후,
        # 0-index로 쓰기 위해 1을 뺀다. (1->0, 8->7)
        row = int(pos[1]) - 1

        # 비숍이 있는 칸을 occupied에 기록
        occupied.add((row, col))

    # ------------------------------------------------------------
    # 2) 비숍이 공격 가능한 칸들을 저장하는 집합(set)
    #    attacked에 들어있는 칸은 "말을 놓으면 즉시 잡히는 칸"이다.
    # ------------------------------------------------------------
    attacked = set()

    # 비숍은 대각선으로만 이동하므로 방향은 총 4개:
    # (dr, dc) = (행 변화량, 열 변화량)
    #  - (1, 1)   : 오른쪽 아래 ↘
    #  - (1, -1)  : 왼쪽 아래 ↙
    #  - (-1, 1)  : 오른쪽 위   ↗
    #  - (-1, -1) : 왼쪽 위   ↖
    directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]

    # occupied에 있는 각 비숍을 하나씩 꺼내서 공격 범위를 표시한다.
    for r, c in occupied:
        # 한 비숍에 대해 4방향 모두 탐색
        for dr, dc in directions:

            # 현재 비숍 위치(r, c)에서 한 칸 이동한 위치부터 시작
            rr, cc = r + dr, c + dc

            # 체스판 범위(0~7) 안에 있는 동안 계속 진행
            while 0 <= rr < 8 and 0 <= cc < 8:
                # 이 칸(rr, cc)은 비숍이 한 번에 이동해서 도달할 수 있는 칸이므로 공격 칸
                attacked.add((rr, cc))

                # 만약 그 칸에 다른 비숍(말)이 이미 있으면
                # - 그 칸은 공격 가능(잡을 수 있음)
                # - 하지만 그 뒤 칸들은 '말에 막혀서' 더 이동 불가
                if (rr, cc) in occupied:
                    break

                # 다음 대각선 칸으로 한 칸 더 진행
                rr += dr
                cc += dc

    # ------------------------------------------------------------
    # 3) 안전한 칸 세기
    #    - 안전한 칸: occupied에도 없고 attacked에도 없는 칸
    # ------------------------------------------------------------
    safe_count = 0

    # 8x8 전체 칸을 전부 검사
    for r in range(8):
        for c in range(8):

            # 이미 비숍이 있는 칸이면 새로운 말을 놓을 수 없으니 제외
            if (r, c) in occupied:
                continue

            # 비숍에게 공격당하는 칸이면 놓는 즉시 잡히므로 제외
            if (r, c) in attacked:
                continue

            # 위 두 조건을 통과하면 안전한 칸
            safe_count += 1

    # 최종 안전 칸 개수 반환
    return safe_count


# ------------------------------------------------------------
# [테스트 코드] (문제 예시)
# ------------------------------------------------------------

bishops1 = ["D5"]
ret1 = solution(bishops1)
print("solution 함수의 반환 값은", ret1, "입니다.")  # 예시: 50

bishops2 = ["D5", "E8", "G2"]
ret2 = solution(bishops2)
print("solution 함수의 반환 값은", ret2, "입니다.")  # 예시: 42

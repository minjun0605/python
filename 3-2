# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
# (한글이 포함된 환경에서도 문자열/주석이 깨지지 않도록 인코딩 선언)

def func_a(arr, s):
    """
    [기능] arr(리스트) 안에 문자열 s가 이미 존재하는지 확인하는 함수
    - 존재하면 True, 없으면 False 반환

    [이유]
    팰린드롬 부분 문자열을 찾을 때, 같은 문자열이 여러 번 나올 수 있다.
    예) "aaaa"에서 "aa"는 여러 위치에서 나오지만, 우리는 "aa"를 1번만 저장해야 함(중복 제거).
    """
    return s in arr


def func_b(s):
    """
    [기능] 문자열 s가 팰린드롬(palindrome)인지 판별하는 함수
    - 팰린드롬: 앞에서 읽으나 뒤에서 읽으나 동일한 문자열
      예) "aba", "abba"는 True / "abca"는 False

    [방법]
    문자열 양 끝에서부터 가운데로 오면서 같은지 비교한다.
    - 길이가 length라면:
      i번째 문자와 (length - i - 1)번째 문자를 비교
    - 절반(length//2)까지만 비교하면 충분
    """
    length = len(s)

    # 앞/뒤 문자를 하나씩 비교 (가운데까지)
    for i in range(length // 2):
        # 하나라도 다르면 팰린드롬이 아님
        if s[i] != s[length - i - 1]:
            return False

    # 끝까지 모두 같으면 팰린드롬
    return True


def func_c(palindromes, k):
    """
    [기능] palindromes 리스트를 사전순으로 정렬한 뒤,
          k번째(1-indexed) 팰린드롬 문자열을 반환한다.
          (없으면 "NULL" 반환)

    [주의]
    - k는 1부터 시작 (k=1이면 첫 번째 원소)
    - 리스트 길이가 k보다 작으면 k번째가 존재하지 않으므로 "NULL"
    """
    # 사전순 정렬 (문자열 비교는 파이썬에서 기본이 사전순)
    palindromes = sorted(palindromes)

    # 팰린드롬 개수가 k개 미만이면 "NULL"
    if len(palindromes) < k:
        return "NULL"
    else:
        # k번째는 인덱스로는 k-1
        return palindromes[k - 1]


def solution(s, k):
    """
    [목표]
    문자열 s에서 만들 수 있는 '모든 부분 문자열' 중 팰린드롬만 골라내고,
    중복을 제거한 뒤, 사전순으로 정렬했을 때 k번째 팰린드롬을 반환한다.
    없다면 "NULL"을 반환한다.

    [전체 흐름]
    1) 모든 부분 문자열(substring)을 만든다.
       - 시작점 start_idx를 0부터 끝까지 바꾸고
       - 길이 cnt를 1부터 가능한 최대까지 바꿔서 sub_s를 생성
    2) sub_s가 팰린드롬인지(func_b) 확인
    3) 팰린드롬이면, 이미 저장된 적 있는지(func_a) 확인
       - 없으면 palindromes에 추가 (중복 제거)
    4) 전부 찾고 나서 func_c로 정렬 + k번째 반환

    [입력 조건]
    - s 길이: 1 이상 100 이하
    - k: 200 이하
    """

    # 팰린드롬 부분 문자열을 저장할 리스트 (중복 없이 저장할 예정)
    palindromes = []

    # 문자열 길이
    length = len(s)

    # start_idx: 부분 문자열의 시작 인덱스 (0 ~ length-1)
    for start_idx in range(length):

        # cnt: 부분 문자열의 길이
        # start_idx부터 시작할 때 가능한 길이의 최대는 (length - start_idx)
        # cnt를 1부터 그 최대까지 돌리며 모든 부분 문자열을 만든다.
        for cnt in range(1, length - start_idx + 1):

            # 부분 문자열 추출: s[start_idx]부터 길이 cnt만큼
            sub_s = s[start_idx : start_idx + cnt]

            # (1) sub_s가 팰린드롬인지 검사
            if func_b(sub_s) == True:

                # (2) palindromes 리스트에 이미 있는지 검사
                #     - 없으면(=False) 추가
                if func_a(palindromes, sub_s) == False:
                    palindromes.append(sub_s)

    # (3) 모든 팰린드롬을 모은 뒤,
    #     사전순 정렬 후 k번째 반환 (없으면 "NULL")
    answer = func_c(palindromes, k)
    return answer


# -------------------------
# [테스트 코드] (문제 예시)
# -------------------------

# 예시 #1
s1 = "abcba"
k1 = 4
ret1 = solution(s1, k1)
print("solution 함수의 반환 값은", ret1, "입니다.")  # "bcb" 기대

# 예시 #2
s2 = "ccddcc"
k2 = 7
ret2 = solution(s2, k2)
print("solution 함수의 반환 값은", ret2, "입니다.")  # "NULL" 기대
